<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Skyscrapers</title>

    <style>
        html,
        head,
        body {
            margin: 0;
            padding: 5px;
            background-color: #2a2a2a;
        }

        #canvas {
            width: 1000px;
            height: 700px;
            background-color: #da6052;
        }

        #error-box {
            color: #fd8080;
            font-weight: 500;
            font-size: 18pt;
            border: 1px solid white;
            padding: 25px;
            margin-top: 20px;
        }

        .error-box-title {
            color: #eee;
            border-bottom: 1px solid gray;
        }

        .container {
            position: relative;
        }

        #overlay {
            position: absolute;
            left: 10px;
            /* 870 */
            top: 10px;
            /* 620 */
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: monospace;
            padding: 1em;
        }
    </style>
</head>

<body>
    <div class="container">
        <canvas id="canvas">
            <!-- This message shows up only if the Canvas element isn't supported -->
            HTML5 canvas not supported in your browser!
        </canvas>

        <div id="overlay" hidden>
            <div>AngleX: <span id="info-angleX"></span></div>
            <div>AngleY: <span id="info-angleY"></span></div>
            <div>Id: <span id="info-id"></span></div>
        </div>
    </div>

    <div id="error-box">
        <span class="error-box-title"></span>
    </div>


    <!-- SCRIPTS -->

    <script id="simple-texture-vertex-shader-3d" type="x-shader/x-vertex">

        attribute vec4 a_position;
        attribute vec2 a_texcoord;
        attribute vec3 a_normal;

        uniform mat4 u_matrix;
        uniform mat4 u_worldInverseTranspose;
        
        varying vec2 v_texcoord;
        varying vec3 v_normal;

        void main() {
            // Multiply the position by the matrix.
            gl_Position = u_matrix * a_position;

            v_texcoord = a_texcoord;
            v_normal = mat3(u_worldInverseTranspose) * a_normal;
        }
    </script>

    <script id="simple-texture-fragment-shader-3d" type="x-shader/x-fragment">
        precision mediump float;

        // Passed in from the vertex shader.
        varying vec2 v_texcoord;
        varying vec3 v_normal;

        uniform sampler2D u_texture;
        uniform vec3 u_reverseLightDirection;

        void main() {
            vec3 normal = normalize(v_normal);

            float light = dot(normal, u_reverseLightDirection);

            gl_FragColor = texture2D(u_texture, v_texcoord);
            gl_FragColor.rgb *= light;
        }
    </script>


    <!---------------->

    <!-- vertex shader -->
    <script id="pick-vertex-shader" type="x-shader/x-vertex">
    attribute vec4 a_position;
    
    uniform mat4 u_viewProjection;
    uniform mat4 u_world;
    
    void main() {
      // Multiply the position by the matrices
      gl_Position = u_viewProjection * u_world * a_position;
    }
  </script>
    <!-- fragment shader -->
    <script id="pick-fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    
    uniform vec4 u_id;
    
    void main() {
       gl_FragColor = u_id;
    }
  </script>

    <!---------------->

    <script id="text-vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
        attribute vec2 a_texcoord;
        
        uniform mat4 u_matrix;
        
        varying vec2 v_texcoord;
        
        void main() {
          // Multiply the position by the matrix.
          gl_Position = u_matrix * a_position;
        
          // Pass the texcoord to the fragment shader.
          v_texcoord = a_texcoord;
        }
    </script>

    <!-- fragment shader -->
    <script id="text-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        
        // Passed in from the vertex shader.
        varying vec2 v_texcoord;
        
        uniform sampler2D u_texture;
        
        void main() {
           gl_FragColor = texture2D(u_texture, v_texcoord);
        }
    </script>

    <!------------------>

    <script id="solid-color-vertex-shader" type="x-shader/x-vertex">
        attribute vec4 a_position;
        attribute vec3 a_normal;

        uniform mat4 projection, modelview, normalMat; // invert transpose

        uniform int mode;   // Rendering mode
        uniform float Ka;   // Ambient reflection coefficient
        uniform float Kd;   // Diffuse reflection coefficient
        uniform float Ks;   // Specular reflection coefficient
        uniform float shininessVal; // Shininess
        // Material color
        uniform vec3 ambientColor;
        uniform vec3 diffuseColor;
        uniform vec3 specularColor;
        uniform vec3 lightPos; // Light position

        varying vec3 normalInterp;
        varying vec3 vertPos;
        varying vec4 color; //color

        void main() {
            vec4 vertPos4 = modelview * a_position;
            vertPos = vec3(vertPos4) / vertPos4.w;
            normalInterp = vec3(normalMat * vec4(a_normal, 0.0));
            gl_Position = projection * vertPos4;

            vec3 N = normalize(normalInterp);
            vec3 L = normalize(lightPos - vertPos);
            // Lambert's cosine law
            float lambertian = max(dot(N, L), 0.0);
            float specular = 0.0;
            if(lambertian > 0.0) {
                vec3 R = reflect(-L, N);      // Reflected light vector
                vec3 V = normalize(-vertPos); // Vector to viewer
                // Compute the specular term
                float specAngle = max(dot(R, V), 0.0);
                specular = pow(specAngle, shininessVal);
            }
            color = vec4(Ka * ambientColor +
                        Kd * lambertian * diffuseColor +
                        Ks * specular * specularColor, 1.0);

            // only ambient
            if(mode == 2) color = vec4(Ka * ambientColor, 1.0);
            // only diffuse
            if(mode == 3) color = vec4(Kd * lambertian * diffuseColor, 1.0);
            // only specular
            if(mode == 4) color = vec4(Ks * specular * specularColor, 1.0);
        }

    </script>

    <script id="solid-color-fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 color;
        
        void main() {
            gl_FragColor = color;
        }
    </script>

    <script src="./resources/webgl-utils.js"></script>
    <script src="./resources/dat.gui.js"></script>
    <script src="./resources/m4.js"></script>

    <script src="grattacieli.js" type="module"></script>
</body>

</html>